<!DOCTYPE html>
<html>
<head>
  <title>TerraSphere Build Editor</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/app.css">
  <link rel="shortcut icon" href="https://www.terrarp.com//favicon.ico">

  <!-- Shared modules -->
  <script src="shared/state-manager.js"></script>
  <script src="shared/build-encoder.js"></script>
  <script src="shared/loading-manager.js"></script>
  <script src="shared/calculations.js"></script>

  <!-- Data files -->
  <script src="resource/masteries.js"></script>
  <script src="resource/expertise.js"></script>
  <script src="resource/actions.js"></script>
  <script src="resource/safecharacters.js"></script>
  <script src="resource/armor-abilities.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
      text-align: center;
      margin-top: 100px;
      color: white;
    }

    .loading {
      font-size: 18px;
      margin: 20px 0;
    }

    .redirect-link {
      color: #47cbdd;
      text-decoration: none;
    }

    .redirect-link:hover {
      text-decoration: underline;
    }

    .error {
      color: #ff6b6b;
      margin: 20px;
      padding: 20px;
      background: rgba(255, 107, 107, 0.1);
      border-radius: 5px;
      display: inline-block;
    }

    /* Fix loading spinner centering on index page */
    #status .loading-container {
      margin-top: -50px; /* Offset the body margin-top */
      min-height: 300px; /* Increased height for better centering */
      text-align: center; /* Ensure all inline elements are centered */
    }

    /* Ensure spinner animations are perfectly centered */
    #status .loading-container .spinner-ring,
    #status .loading-container .spinner-mastery,
    #status .loading-container .spinner-progress,
    #status .loading-container .spinner-data,
    #status .loading-container .spinner-dots {
      margin: 0 auto; /* Center the spinner horizontally */
      display: block; /* Ensure block display for margin auto to work */
    }

    #status .loading-container .spinner-dots {
      display: flex; /* Restore flex for dots, but still centered */
      justify-content: center;
    }

    /* Fix mastery spinner pseudo-elements positioning */
    #status .loading-container .spinner-mastery {
      position: relative; /* Ensure relative positioning for pseudo-elements */
    }

    #status .loading-container .spinner-mastery::before,
    #status .loading-container .spinner-mastery::after {
      top: 0;
      left: 0;
      transform-origin: center center;
    }
  </style>
</head>
<body>
<h1>TerraSphere Build Editor</h1>
<div id="status">Loading...</div>

<script>
  // Initialize global objects
  window.buildState = window.buildState || new BuildState();

  function clearPreviousState() {
    try {
      if (window.buildState) {
        window.buildState.reset();
      } else {
        localStorage.removeItem('tsbuilder_state');
      }
    } catch (error) {
      console.error('Failed to clear previous state:', error);
    }
  }

  async function handleBuildCode() {
    const hash = window.location.hash;
    console.log('üîó Index: Processing hash:', hash);

    if (hash.includes('#load.')) {
      const charId = hash.slice(6);
      await loadCharacterProfile(charId);
    } else if (hash.includes('#import.')) {
      const buildCode = hash.slice(8);
      await importBuildCode(buildCode);
    } else if (hash.includes('#sample.')) {
      const buildCode = hash.slice(8);
      await importBuildCode(buildCode);
    } else if (hash.includes('#compact.')) {
      const buildCode = hash.slice(9);
      await importBuildCode(buildCode, true);
    } else {
      clearPreviousState();
      redirectToMasterySelector();
    }
  }

  async function loadCharacterProfile(charId) {
    try {
      LoadingManager.show('status', {
        type: 'data',
        text: 'Loading character profile...'
      });
      console.log('üì• Index: Loading character profile:', charId);

      // Production API endpoint
      const response = await fetch(`https://spherical-worlds.com/tsbeta/api/terrasphere-charactermanager/?id=${charId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Xf-Api-Key': 'nY3YHH7VMoIIVj8WgvmFfBG2tLeWyzUj'
        }
      });

      // Development API endpoint
      // const response = await fetch(`http://localhost:3001/api/terrarp-user/${charId}`, {
      //   method: 'GET',
      //   headers: {
      //     'Content-Type': 'application/json',
      //     'Xf-Api-Key': 'nY3YHH7VMoIIVj8WgvmFfBG2tLeWyzUj'
      //   }
      // });

      if (!response.ok) {
        throw new Error('Failed to load character data');
      }

      const characterData = await response.json();
      console.log('‚úÖ Index: Character data received:', characterData);
      console.log('üîç Index: Expertises data:', characterData.expertises);
      console.log('üîç Index: Equipment data:', characterData.equipment);

      // Parse character masteries for the system
      const chosenMasteries = [];
      const chosenMasteriesRanks = [];

      if (characterData.masteries && characterData.masteries.length > 0) {
        for (let i = 0; i < characterData.masteries.length; i++) {
          // Convert mastery name to standard format (lowercase with hyphens)
          const masteryName = characterData.masteries[i].Mastery.toLowerCase().replace(/\s+/g, '-');
          const rank = characterData.masteries[i].Rank;

          chosenMasteries.push(masteryName);

          // Convert rank letter to number (0=E, 1=D, 2=C, 3=B, 4=A, 5=S)
          const rankMap = {'E': 0, 'D': 1, 'C': 2, 'B': 3, 'A': 4, 'S': 5};
          chosenMasteriesRanks.push(rankMap[rank] || 0);
        }
      }

      // Parse equipment ranks (separate from expertise)
      const rankMap = {'E': 0, 'D': 1, 'C': 2, 'B': 3, 'A': 4, 'S': 5};
      let armorType = 'medium';
      let accessoryType = 'cloak';
      let weaponRank = 0;
      let armorRank = 0;
      let accessoryRank = 0;

      if (characterData.equipment && characterData.equipment.length >= 1) {
        // Parse weapon rank
        const weaponRankLetter = Object.values(characterData.equipment[0])[0];
        weaponRank = rankMap[weaponRankLetter] || 0;

        // Parse armor rank and type
        if (characterData.equipment.length >= 2) {
          const armorRankLetter = Object.values(characterData.equipment[1])[0];
          const armorKey = Object.keys(characterData.equipment[1])[0];

          if (armorKey === 'Heavy Armor') {
            armorType = 'heavy';
          } else if (armorKey === 'Medium Armor') {
            armorType = 'medium';
          } else if (armorKey === 'Light Armor') {
            armorType = 'light';
          }

          armorRank = rankMap[armorRankLetter] || 0;
        }

        // Parse accessory rank and type if available
        if (characterData.equipment.length >= 3) {
          const accessoryRankLetter = Object.values(characterData.equipment[2])[0];
          const accessoryKey = Object.keys(characterData.equipment[2])[0];

          if (accessoryKey === 'Combat Accessory') {
            accessoryType = 'combat';
          } else if (accessoryKey === 'Utility Accessory') {
            accessoryType = 'utility';
          } else if (accessoryKey === 'Magic Accessory') {
            accessoryType = 'magic';
          } else {
            accessoryType = 'other';
          }

          accessoryRank = rankMap[accessoryRankLetter] || 0;
        }
      }

      // Parse character expertises (acrobatics, strength, etc.) - separate from equipment
      const chosenExpertise = [];
      const chosenExpertiseRanks = [];

      if (characterData.expertises && characterData.expertises.length > 0) {
        for (let i = 0; i < characterData.expertises.length; i++) {
          // Convert expertise name to standard format (lowercase with hyphens)
          const expertiseName = characterData.expertises[i].Expertise.toLowerCase().replace(/\s+/g, '-');
          const rank = characterData.expertises[i].Rank;

          chosenExpertise.push(expertiseName);
          chosenExpertiseRanks.push(rankMap[rank] || 0);
        }
      }

      console.log('üîç Index: Parsed expertise:', {
        chosenExpertise: chosenExpertise,
        chosenExpertiseRanks: chosenExpertiseRanks,
        armorType: armorType,
        accessoryType: accessoryType
      });

      // Update build state with all imported data
      const state = window.buildState;
      state.updateState({
        characterName: characterData.username || '',
        characterTitle: characterData.custom_title || '',
        characterRace: characterData.Race || '',
        avatarUrl: characterData.avatar_urls?.m || '',
        profileBannerUrl: characterData.banner_urls?.l || '',
        ng: (characterData.secondary_user_group_ids &&
          Array.isArray(characterData.secondary_user_group_ids) &&
          characterData.secondary_user_group_ids.includes(30)) ? 1 : 0,
        chosenMasteries: chosenMasteries,
        chosenMasteriesRanks: chosenMasteriesRanks,
        chosenExpertise: chosenExpertise,
        chosenExpertiseRanks: chosenExpertiseRanks,
        weaponRank: weaponRank,
        armorRank: armorRank,
        accessoryRank: accessoryRank,
        armorType: armorType,
        accessoryType: accessoryType,
        chosenActions: []
      });

      console.log('‚úÖ Index: Character loaded into state:', state.state);

      // Validate the loaded state with detailed checking
      const masteryValid = state.state.chosenMasteries.length > 0 &&
        state.state.chosenMasteriesRanks.length === state.state.chosenMasteries.length;
      const expertiseValid = state.state.chosenExpertise.length > 0 &&
        state.state.chosenExpertiseRanks.length === state.state.chosenExpertise.length;

      let masteryRankValidation = {valid: true, message: ''};
      let expertiseRankValidation = {valid: true, message: ''};

      if (window.CharacterCalculations && typeof window.CharacterCalculations.validateMasteryRanks === 'function') {
        masteryRankValidation = window.CharacterCalculations.validateMasteryRanks(state.state.chosenMasteriesRanks);
        expertiseRankValidation = window.CharacterCalculations.validateMasteryRanks(state.state.chosenExpertiseRanks);
      } else {
        console.warn('‚ö†Ô∏è Index: CharacterCalculations not loaded, skipping rank validation');
      }

      const isValid = masteryValid && expertiseValid && masteryRankValidation.valid && expertiseRankValidation.valid;

      console.log('üîç Index: State validation:', {
        isValid: isValid,
        masteryValid: masteryValid,
        expertiseValid: expertiseValid,
        masteryRankValidation: masteryRankValidation,
        expertiseRankValidation: expertiseRankValidation,
        masteries: state.state.chosenMasteries,
        masteriesRanks: state.state.chosenMasteriesRanks,
        expertise: state.state.chosenExpertise,
        expertiseRanks: state.state.chosenExpertiseRanks
      });

      if (!isValid) {
        console.warn('‚ö†Ô∏è Index: State validation failed - character does not meet rank distribution rules');

        // Clear the invalid state
        state.reset();

        LoadingManager.hide('status');

        let errorDetails = '';
        if (!masteryRankValidation.valid) {
          errorDetails += `<p><strong>Mastery Ranks:</strong> ${masteryRankValidation.message || 'Invalid distribution'}</p>`;
        }
        if (!expertiseRankValidation.valid) {
          errorDetails += `<p><strong>Expertise Ranks:</strong> ${expertiseRankValidation.message || 'Invalid distribution'}</p>`;
        }

        document.getElementById('status').innerHTML = `
            <div class="error">
              <h3>Invalid Character Configuration</h3>
              <p>This character does not meet the rank distribution requirements.</p>
              ${errorDetails}
              <p><strong>Required:</strong> 1√óS, 2√óA, 3√óB for both masteries and expertise.</p>
              <p><a href="mastery-selector.html" class="redirect-link">Start New Build ‚Üí</a></p>
            </div>
          `;
        return;
      }

      LoadingManager.show('status', {
        type: 'mastery',
        text: 'Character loaded! Redirecting to action selector...'
      });

      setTimeout(() => {
        window.location.href = 'action-selector.html';
      }, 1500);

    } catch (error) {
      console.error('‚ùå Index: Error loading character:', error);

      LoadingManager.hide('status');
      document.getElementById('status').innerHTML = `
          <div class="error">
            <h3>Import Failed</h3>
            <p>Failed to load character profile: ${error.message}</p>
            <p><a href="mastery-selector.html" class="redirect-link">Start New Build ‚Üí</a></p>
          </div>
        `;
    }
  }

  async function importBuildCode(buildCode, isCompact = false) {
    try {
      LoadingManager.show('status', {
        type: 'progress',
        text: 'Importing build...'
      });
      console.log('üì• Index: Importing build code:', buildCode.substring(0, 20) + '...');

      if (!window.BuildEncoder) {
        throw new Error('Build encoder not loaded');
      }

      // Load data
      if (!window.masteries) {
        console.error('‚ùå Index: masteries not loaded');
        throw new Error('mastery data not loaded');
      }
      if (!window.expertise) {
        console.error('‚ùå Index: expertise not loaded');
        throw new Error('expertise data not loaded');
      }
      if (!window.actionlist) {
        console.error('‚ùå Index: actionlist not loaded');
        throw new Error('action data not loaded');
      }

      // Decode the build using unified decode method
      const buildData = window.BuildEncoder.decodeBuildString(buildCode);
      console.log('‚úÖ Index: Build imported successfully:', buildData);

      // Update state with imported data
      window.buildState.updateState(buildData);

      // Redirect to build sheet to display the imported build
      window.location.href = 'build-sheet.html';
    } catch (error) {
      console.error('‚ùå Index: Import failed:', error);

      LoadingManager.hide('status');
      document.getElementById('status').innerHTML = `
          <div class="error">
            <h3>Import Failed</h3>
            <p>Unable to import the build code: ${error.message}</p>
            <p>The build code may be invalid or from an incompatible version.</p>
            <p><a href="mastery-selector.html" class="redirect-link">Start New Build ‚Üí</a></p>
          </div>
        `;
    }
  }

  function redirectToMasterySelector() {
    LoadingManager.show('status', {
      type: 'mastery',
      text: 'Redirecting to build creator...'
    });

    setTimeout(() => {
      document.getElementById('status').innerHTML += `
          <p><a href="mastery-selector.html" class="redirect-link">Click here if not redirected automatically</a></p>
        `;
    }, 1500);

    setTimeout(() => {
      window.location.href = 'mastery-selector.html';
    }, 2000);
  }

  // Wait for page to load, then handle build codes
  window.addEventListener('load', function () {
    console.log('üöÄ Index: Page loaded, processing...');
    console.log('üîç Index: CharacterCalculations available?', typeof window.CharacterCalculations);
    console.log('üîç Index: validateMasteryRanks available?', typeof window.CharacterCalculations?.validateMasteryRanks);

    // Small delay to ensure all scripts are loaded
    setTimeout(() => {
      handleBuildCode();
    }, 100);
  });

  // Handle hash changes (if user manually changes URL)
  window.addEventListener('hashchange', function () {
    console.log('üîÑ Index: Hash changed, reprocessing...');
    handleBuildCode();
  });
</script>
</body>
</html>